import os
from langchain_core.prompts import PromptTemplate
from langchain_groq import ChatGroq
from langchain_core.output_parsers import StrOutputParser
from langchain.agents import Tool
from dotenv import load_dotenv, find_dotenv
import json



dotenv_path = find_dotenv("./.env")
load_dotenv(dotenv_path)

CHAT_HISTORY_FILE = "chat_history.json"

def load_recent_history():
    """Load recent chat history for context."""
    if os.path.exists(CHAT_HISTORY_FILE):
        with open(CHAT_HISTORY_FILE, "r") as f:
            chat_history = json.load(f)
        return chat_history[-3:]  # Get the last 3 interactions for context
    return []

def save_to_chat_history(user_input, tool_output):
    """Save the current interaction to chat_history.json in the specified format."""
    if os.path.exists(CHAT_HISTORY_FILE):
        with open(CHAT_HISTORY_FILE, "r") as f:
            chat_history = json.load(f)
    else:
        chat_history = []

    # Prepare the current interaction format
    interaction = {
        "user": user_input,
        "agent": {
            "input": user_input,
            "chat_history": load_recent_history(),
            "output": tool_output
        }
    }

    # Append the new interaction to the chat history
    chat_history.append(interaction)

    # Save back to the JSON file
    with open(CHAT_HISTORY_FILE, "w") as f:
        json.dump(chat_history, f, indent=4)

def decomposerTool(input_text, code_gen: bool = False):
    recent_history = load_recent_history()
    context = " ".join([f"User: {item['user']} Agent: {item['agent']}" for item in recent_history])
    llm = ChatGroq(model="llama3-70b-8192", temperature=0)
    prompt = PromptTemplate(
template = """
With the following recent history as context: {context}

You are an AI expert with extensive knowledge in tool integration and workflow design. Your task is to decompose a given problem into necessary functions and provide a structured breakdown of the workflow to solve the problem efficiently. Follow these steps:

### Problem Analysis
1. **Understand the Problem**: Analyze the task thoroughly to identify the primary goal and sub-tasks.
2. **Subdivide the Problem**: Decompose the task into individual, manageable functions.

### Function Breakdown
For each identified function:
- **Name of the Function**: Provide a meaningful name.
- **Input**: Specify the inputs required by the function.
- **Output**: Describe the output generated by the function.
- **Processing**: Summarize the functionality or logic implemented in the function.

### Workflow Design
1. **Define Workflow**: Describe how the functions interact. Specify:
   - The intended order of execution.
   - How the output of one function is passed as input to the next.
2. **Define the Tool**: Create a tool named `run` that encapsulates the workflow and calls the functions in the correct sequence.
   - Ensure the tool:
     - Accepts the required input for the workflow.
     - Handles error propagation gracefully.
     - Returns the final output of the workflow.

### Error Handling and Optimization
- **Error Handling**: Identify potential errors at each function or step. Propose mitigation strategies.
- **Optimization**: Suggest improvements to streamline the workflow, ensuring accuracy and efficiency.

### Final Solution
Deliver the complete solution, including:
- Function definitions with clear input, output, and processing logic.
- The `run` tool that invokes the functions in the correct order to execute the workflow.
- Justifications for the choices made.

KEEP IN MIND THAT YOU ARE TO ONLY CREATE A BREAKDOWN AND NOT TO PROVIDE THE CODE .
{input_text}
"""
,
        input_variables=["input_text","context"],
    )
    chain = prompt | llm | StrOutputParser()
    result = chain.invoke({"context": context, "input_text": input_text})

    save_to_chat_history(input_text, result)

    return result


decomp = Tool(
    name='Decomposer',
    func=decomposerTool,
    description="This is to be used when the user wants to breakdown their task into specific tools needed"
)
